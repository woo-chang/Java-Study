# Chapter 07 객체지향 프로그래밍 2

## 1. 상속(inheritance)

### 1) 상속의 정의와 장점
- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
  - 적은 양으로 코드 작성
  - 코드를 공통적으로 관리 → 유지보수 용이
  - 코드 중복을 최소화
- `조상 클래스` : 부모 클래스, 상위 클래스, 기반 클래스
- `자손 클래스` : 자식 클래스, 하위 클래스, 파생된 클래스
- 조상 클래스가 변경되면 자동으로 자손 클래스에 영향을 주지만, 자손 클래스의 변경은 조상 클래스에 영향을 주지 않는다
- **생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.**
- 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성

### 2) 클래스간의 관계 - 포함관계
- 멤버변수로 다른 클래스의 `참조변수`를 선언하는 것
- 이해하기 쉽고 관리하기 쉽다

### 3) 클래스간의 관계 결정하기
- `이다`와 `가지고있다`를 사용하여 적절한 것 선택
- `상속 관계` : ~은 ~이다
- `포함 관계` : ~은 ~을 가지고 있다
- 참조변수의 출력이나 덧셈연산자를 이용한 참조변수와 문자열의 결합에는 `toString()`이 자동적으로 호출

### 4) 단일 상속 (single inheritance)
- 자바에서는 오직 단일 속상만 허용
- 다중 상속의 단점
  - 클래스가 매우 복잡해진다
  - 멤버이름이 같은 경우 구별할 수 없다
- 클래스 간의 관계가 명확해지고 코드를 더욱 신뢰

### 5) Object클래스 - 모든 클래스의 조상
- 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동으로 Object 클래스를  상속
- toString, equals를 정의하지 않고 사용할 수 있었던 이유는 이 때문

<br>

## 2. 오버라이딩(overriding)

### 1) 오버라이딩이란?
- 상속받은 메서드의 내용을 변경하는 것

### 2) 오버라이딩의 조건
1. 이름이 같아야 한다
2. 매개변수가 같아야 한다
3. 반환타입이 같아야 한다
- 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다
  - public > protected > default > private
- 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다
  - 개수뿐 아니라 범위의 문제
- 인스턴스 메서드를 static메서드 또는 그 반대로 변경할 수 없다
- static → static은 별개의 메서드를 정의한 것 뿐 오버라이딩이 아니다

### 3) 오버로딩 vs 오버라이딩
- `오버로딩` : 새로운 메서드를 정의하는 것
- `오버라이딩` : 상속받은 메서드의 내용을 변경하는 것

### 4) super
- 상속받은 멤버와 자신의 멤버가 같은 경우 `super`를 붙여서 구분
- 모든 인스턴스 메서드에는 속한 인스턴스의 주소가 지역변수로 저장되는데 이것이 `super`와 `this`

### 5) super() - 조상 클래스의 생성자
- `super()`는 조상 클래스의 생성자를 호출하는데 사용
- 조상 클래스의 멤버가 먼저 초기화되어 있어야 사용 가능성이 존재하기에 생성자의 첫줄에 위치
- 조상 클래스 생성자 호출은 상속관계를 거슬러 올라가면서 계속 되기에 적어줘야한다
- 적어주지 않는다면 Object 클래스를 제외하고 컴파일러에 의해 자동적으로 생성

<br>

## 3. package와 import

### 1) 패키지(package)
- `패키지` : 클래스의 묶음
- 클래스의 실제 이름을 패키지명을 포함
- 하나의 소스파일에는 첫 번째 문장으로 단 한번의 패키지 선언만을 허용
- 모든 클래스는 반드시 하나의 패키지에 속해야 한다
- 패키지는 점을 구분자로 하여 계층구조로 구성
- 패키지는 물리적으로 클래스 파일을 포함하는 하나의 디렉토리

### 2) 패키지의 선언
- 대소문자 모두 가능하지만 클래스와 구분을 위해 `소문자`를 원칙
- 패키지를 작성하지 않으면 자바에서 제공하는 `이름없는 패키지(unnamed package)`에 속함

### 3) import문
- 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용
- `import`문을 사용하면 패키지 이름 생략하고 클래스 사용 가능
  - 컴파일러에게 패키지에 대한 정보를 제공하는 것
- import문은 프로그램의 성능에 영향을 거의 미치지 않는다

### 4) import문의 선언
- `*`를 사용하면 컴파일러가 컴파일러의 이름을 찾는 수고를 덜어줄 뿐 성능에 영향은 미치지 않는다
- 어느 패키지에 속하는지 구별하기 어려운 단점이 존재하고 하위 패키지의 클래스까지 포함하는 것은 아니다
- 같은 패키지의 클래스는 import 사용하지 않고 패키지명 생략 가능
- String, System를 import 없이 사용할 수 있었던 이유는 모든 소스 파일에 묵시적으로 `import java.lang.*`이 선언되어 있기 때문

### 5) static import문
- `import static ~`을 사용하면 static 메서드를 사용할 때 클래스 이름 생략 가능

<br>

## 4. 제어자(modifier)

### 1) 제어자란?
- 제어자는 선언부에 함께 사용되어 부가적인 의미를 부여
- 접근 제어자 : public, protected, default, private
- 그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp

### 2) static - 클래스의, 공통적인
- static메서드로 하는 것인 인스턴스를 생성하지 않고도 호출이 가능해서 더 편리하고 속도도 더 빠르다

### 3) final - 마지막의, 변경될 수 없는
- 값을 변경할 수 없고, 오버라이딩 할 수 없고, 상속할 수 없다
- 선언과 초기화가 동시에 이루어져야 하지만 인스턴스 변수인 경우 생성자에서 초기화 가능
  - 인스턴스마다 다른 값을 가질 수 있도록 하기 위함

### 4) abstract - 추상의, 미완성의
- 메서드 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용
- 추상 클래스는 인스턴스를 생성할 수 없다

### 5) 접근 제어자(access modifier)
- 접근 제어자가 지정되어 있지 않다면 `default`임을 의미
- 접근 제어자를 사용하는 이유는 클래스 내부 데이터 보호를 위함
- 외부에는 불필요한 내부적으로 사용되는 부분을 감추기 위함
```java
class Singleton {
	...
	private static Singleton s = new Singleton();

	private Singleton() {
		...
	}

	public static Singleton getSingleton() {
		return this.s;
	}
}
```
- 인스턴스를 생성하지 않고 호출할 수 있도록 `static`, 인스턴스를 미리 생성하기 위해 `static`
- 인스턴스의 개수를 제한할 수 있기에 `싱글톤`처럼 사용 가능
- 생성자가 private인 클래스는 상속할 수 없다
  - 조상 클래스의 생성자가 호출될 수 없기 때문
  - final을 추가하여 상속할 수 없음을 명시적으로 표시

### 6) 제어자(modifier)의 조합
1. 메서드에 static, abstract 함께 사용 불가능
- static은 구현부가 있는 메서드에만 사용 가능
2. 클래스에 abstract, final 함께 사용 불가능
- final은 확장할 수 없음을 의미하지만 abstract는 확장 가능성을 의미
3. abstract메서드의 접근 제어자가 private일 수 없다
- 자손 클래스에서 접근 불가능
4. 메서드에 private, final 같이 사용할 필요 없다
- 둘 중 하나만 사용해도 의미 충분

<br>

## 5. 다형성(polymorphism)

### 1) 다형성이란?
- 다형성이란 여러 가지 형태를 가질 수 있음을 의미
- 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다
- 자식 참조변수로 조상 클래스를 참조할 수 없는 이유는 사용가능한 것보다 사용 범위가 커지기 때문

### 2) 참조변수의 형변환
- 참조변수도 형변환이 가능하다
- 자손타입 → 조상타입(Up-casting) : 형변환 생략가능
- 조상타입 → 자손타입(Down-casting) : 형변환 생략불가
- **명시적 형변환이 가능한 것은 해당 인스턴스를 가지지만 형변환으로 범위가 줄어든 것에 대해서만 가능**
  - 조상 인스턴스에서 바로 자손 인스턴스로 형변환은 에러를 발생
- 컴파일시에는 참조변수간 타입만 체크하기 때문에 에러가 발생하지 않지만 실행시에는 에러가 발생
- 따라서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요

### 3) instanceof 연산자
- 왼쪽에는 참조변수를 오른쪽에는 타입
- `true` 결과가 나오면 해당 타입으로 변환 가능하다는 의미

### 4) 참조변수와 인스턴스의 연결
- `인스턴스 메서드`인 경우 실제 인스턴스 메서드가 호출되지만 `멤버변수`의 경우 참조변수 타입에 따라 달라진다
  - 상속받은 변수의 이름이 동일한 경우에만 적용
- private로 지정해두고 메서드를 통해 접근하도록
  - 직접 접근하면 값을 예측할 수 없는 결과가 발생

### 5) 매개변수의 다형성
- 동일한 기능의 메서드를 하나로 처리 가능

### 6) 여러 종류의 객체를 배열로 다루기
- 조상 타입의 배열을 생성하면 자손 타입을 전부 담을 수 있는 배열 생성 가능
- 크기를 지정하지 않으려면 `Vector` 클래스 사용
  - 내부적으로 `Object` 타입의 배열
  - 배열의 크기를 알아서 관리해주기 때문에 인스턴스 개수를 신경쓰지 않아도 된다
  - 단지 배열의 크기를 동적으로 관리해주는 클래스
- `ArrayList` VS `Vector`
  - ArrayList는 Vector를 보완하기 위해 만든 클래스
  - Thread-Safe
  - 동기화 문제

<br>

## 6. 추상클래스(abstract class)

### 1) 추상클래스란?
- 추상클래스는 미완성 설계도
- 추상클래스에도 생성자가 있으며 멤버변수와 메서드를 가질 수 있다

### 2) 추상메서드(abstract method)
- 선언부만 작성하고 구현부는 작성하지 않은 메서드
- 주석을 통해 어떤 기능을 수행할 목적으로 작성했는지 설명

### 3) 추상클래스의 작성
- 기존 클래스의 공통 부분을 뽑아내고 조상 클래스를 작성하는 것
```java
abstract void play(); // 추상 메서드

void play() {} // 추상 메서드 구현 - 구현부에 내용이 없다라도 구현한 것으로 간주
```
- 빈 구현부를 만들기보다는 abstract를 붙이는 이유는 자손 클래스에서 메서드 구현을 강요하기 위함

<br>

## 7. 인터페이스(interface)

### 1) 인터페이스란?
- 일종의 추상 클래스
- 추상 클래스보다 추상화 정도가 높아서 추상 클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다
- 추상 메서드와 상수만을 멤버로 가질 수 있다

### 2) 인터페이스의 작성
- 모든 멤버변수는 `public static final`, 이를 생략할 수 있다
- 모든 메서드는 `public abstract`, 이를 생략할 수 있다
- 생략된 제어자는 컴파일러가 자동으로 추가
- JDK1.8 이후에는 인터페이스에 `static`, `default` 메서드 사용 가능

### 3) 인터페이스의 상속
- 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와 달리 다중 상속이 가능

### 4) 인터페이스의 구현
- 추상클래스처럼 그 자체로는 인스턴스 생성 불가능
- 인터페이스의 메서드 중 일부분만 구현한다면 `abstract`를 붙여서 추상클래스로 선언

### 5) 인터페이스를 이용한 다중상속
- 인터페이스는 `static`상수만 정의할 수 있기에 멤버변수의 충돌이 거의 없다
- 추상 메서드는 구현 내용이 없으므로 조상 클래스의 메서드를 상속받으면 가능, 충돌 감소

### 6) 인터페이스를 이용한 다형성
- 구현한 클래스의 인스턴스를 참조할 수 있으며 인터페이스 타입으로 형변환 가능
- 메서드의 매개변수 타입으로 사용 가능
- **리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미**

### 7) 인터페이스의 장점
- 개발시간을 단축시킬 수 있다
- 표준화가 가능하다
- 서로 관계없는 클래스들에게 관계를 맺어줄 수 있다
- 독립적인 프로그래밍이 가능하다

### 8) 인터페이스의 이해
- 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다
- 메서드를 사용(호출)하는 쪽에서는 사용하려는 메서드의 선언부만 알면 된다

### 9) 디폴트 메서드와 static 메서드
- 기존 인터페이스는 추상 메서드만 가능
  - `java.util.Collection` 인터페이스
  - static 메서드는 `java.util.Collections` 클래스에 구현
- 디폴트 메서드
  - 인터페이스에 메서드가 추가되면 해당 인터페이스를 구현하는 모든 클래스를 변경하는 문제점 보완
  - 추상 메서드의 기본 구현을 제공하는 메서드
  - 여러 인터페이스의 디폴트 메서드 충돌
    - 인터페이스를 구현한 클래스에서 디폴트 메서드 오버라이드
  - 디폴트 메서드와 조상 클래스 메서드 충돌
    - 조상 클래스 메서드를 상속받고 디폴트 메서드를 무시

<br>

## 8. 내부 클래스(inner class)

### 1) 내부 클래스란?
- 내부 클래스의 외부 클래스의 멤버들을 쉽게 접근
- 코드의 복잡성을 줄일 수 있다(캡슐화)

### 2) 내부 클래스의 종류와 특징
- 인스턴스 클래스(instance class)
  - 외부 클래스의 인스턴스 멤버들과 관련된 작업에 사용
- 스태틱 클래스(static class)
  - 외부 클래스의 static 멤버들과 관련되 작업에 사용
- 지역 클래스 (local class)
  - 외부 클래스의 메서드나 초기화블럭 안에 선언, 선언된 영역 내부에서만 사용
- 익명 클래스 (anonymous class)
  - 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스

### 3) 내부 클래스의 선언
- 선언된 위치에 따라 종류가 달라진다

### 4) 내부 클래스의 제어자와 접근성
- 내부 클래스 중 스태틱 클래스만 static멤버를 가질 수 있다
  - 외부 클래스가 생성되지 않을 수 있기 때문
- final static은 상수이므로 가질 수 있다
- 지역 클래스는 final이 붙은 지역변수만 참조 가능
  - 지역변수가 소멸된 시점에 지역 클래스가 참조하려는 문제가 발생할 수 있기 때문
- 컴파일 시 생성되는 파일명은 `외부클래스명$내부클래스명.class`
- 지역 내부 클래스는 다른 메서드에 같은 이름의 클래스가 존재할 수 있기에 내부 클래스 명 앞에 숫자

### 5) 익명 클래스(anonymous class)
- 클래스의 선언과 객체의 생성을 동시에 하는 일회용 클래스
- 생성자를 가질 수 없고 하나의 클래스를 상속받거나 하나의 인터페이스를 구현
```java
new 조상클래스이름() {
	// 멤버 선언
}

new 구현인터페이스이름() {
	// 멤버 선언
}
```
- `외부클래스명$숫자.class`