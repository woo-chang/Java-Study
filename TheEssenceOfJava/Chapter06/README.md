# Chapter 06 객체지향 프로그래밍 1

## 1. 객체지향언어

### 1) 객체지향언어의 역사
- 기본개념은 `실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다`라는 것

### 2) 객체지향언어
1. 코드의 재사용성이 높다
2. 코드의 관리가 용이하다
3. 신뢰성 높은 프로그래밍을 가능하게 한다
- 객체지향개념을 학습할 때 재사용성과 유지보수 그리고 중복된 코드의 제거, 이 세가지 관점에서 보면 보다 쉽게 이해

<br>

## 2. 클래스와 객체

### 1) 클래스와 객체의 정의와 용도
- `클래스의 정의` : 클래스란 객체를 정의해 놓은 것
- `클래스의 용도` : 클래스를 객체를 생성하는데 사용
- `객체의 정의` : 실제로 존재하는 것
- `객체의 용도` : 객체가 가지고 있는 기능과 속성에 따라 다름

### 2) 객체와 인스턴스
- 객체를 만드는 것을 클래스의 인스턴스화
- 만들어진 객체를 클래스의 인스턴스

### 3) 객체의 구성요소 - 속성과 기능
- 객체는 `속성`과 `기능`의 집합
- 속성 : 멤버변수, 특성, 필드, 상태
- 기능 : 메서드, 함수, 행위

### 4) 인스턴스의 생성과 사용
- 인스턴스를 다루기 위해서는 `참조변수`가 반드시 필요하다
- 인스턴스는 참조변수를 통해서만 다룰 수 있으며 참조변수의 타입은 인스턴스 타입과 일치
- 자신을 참조하고 있는 참조변수가 하나도 없는 인스턴스는 `가비지 컬렉터`에 의해 자동적으로 메모리에서 제거

### 5) 객체 배열
- 객체 배열 안에 객체가 저장되는 것은 아니고 객체를 참조하는 주소값이 저장

### 6) 클래스의 또 다른 정의
- `변수` : 하나의 데이터를 저장할 수 있는 공간
- `배열` : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
- `구조체` : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
- `클래스` : 데이터와 함수의 결합(구조체 + 함수)
- 자바와 같은 객체지향언어에서는 클래스가 곧 사용자 정의 타입이다

<br>

## 3. 변수와 메서드

### 1) 선언위치에 따른 변수의 종류
- 변수는 `클래스변수`, `인스턴스변수`, `지역변수` 세 종류가 존재
- `멤버변수`를 제외한 나머지 변수들은 모두 지역변수
- static이 붙으면 클래스변수, 붙지 않으면 인스턴스변수
- **클래스변수**
  - 클래스가 메모리에 올라갔을 때 생성
  - 한 클래스의 모든 인스턴스가 공통적인 값을 유지해야할 때 사용
  - 프로그램이 종료될 때까지 유지
- **인스턴스변수**
  - 인스턴스가 생성됐을 때 생성
- **지역변수**
  - 변수 선언문이 수행되었을 때 생성
  - 블럭을 벗어나면 사용할 수 없다

### 2) 클래스변수와 인스턴스변수
- 인스턴스변수는 인스턴스마다 다른 값을 가지지만, 클래스변수는 모든 인스턴스가 하나의 저장공간을 공유하므로 항상 공통된 값

### 3) 메서드
- 메서드를 사용하는 이유
  1. 높은 재사용성
  2. 중복된 코드의 제거
  3. 프로그램의 구조화

### 4) 메서드의 선언과 구현
- `선언부`와 `구현부`로 이루어져 있다
- 매개변수는 두 변수의 타입이 같아도 변수의 타입을 생략할 수 없다
- 반환값은 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것

### 5) 메서드의 호출
- `main` 메서드는 프로그램 실행 시 `OS`에 의해 자동적으로 호출
- 매개변수로 지정된 값은 메서드의 매개변수로 복사

### 6) return 문
- 현재 실행중인 메서드를 종료하고 호출한 메서드로 돌아간다

### 7) JVM의 메모리 구조
- 응용 프로그램이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 메모리를 용도에 따라 여러 영역으로 나누어 관리
- **메서드 영역**
  - 클래스 파일을 읽어 분석하여 클래스에 대한 정보를 이곳에 저장
  - 클래스변수도 이 영역에 함께 생성
- **힙**
  - 인스턴스가 생성되는 공간
  - 인스턴스변수가 생성되는 공간
- **호출스택**
  - 메서드 작업에 필요한 메모리 공간
  - 지역변수들과 연산의 중간결과를 저장
  - 작업을 마치면 할당된 메모리공간은 반환되어 버려짐
  - 제일 상위의 메서드가 현재 실행중인 메서드, 나머지는 대기상태

### 8) 기본형 매개변수와 참조형 매개변수
- 매개변수 타입이 기본형인 경우 `값`이 복사
  - 값을 읽기만 할 수 있다
- 매개변수 타입이 참조형인 경우 `주소`가 복사
  - 값을 읽고 변경할 수 있다

### 9) 참조형 반환타입
- 반환형이 참조형이라는 것은 객체의 주소를 반환한다는 의미

### 10) 재귀호출(recursive call)
- 메서드 자신을 다시 호출하는 것을 `재귀호출`이라 하고, 재귀호출하는 메서드를 `재귀메서드`라 한다
- 무한 호출을 막기 위해 조건문 함께 사용
- 메서드 호출에 사용되는 과정이 존재하기에 반복문 보다 긴 수행시간
  - 재귀호출이 주는 논리적 간결함 때문에 사용
- 호출한계가 넘어가면 `스택오버플로우 에러`가 발생
- `main` 메서드 또한 자기 자신 호출 가능

### 11) 클래스 메서드(static 메서드)와 인스턴스 메서드
- 인스턴스 메서드는 인스턴스 변수를 필요로 하는 메서드
1. 클래스를 설계할 때, 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다
  - 모든 인스턴스에서 같은 값을 유지하는 변수
2. 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다
  - 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되었기 때문
3. 클래스 메서드(static메서드)는 인스턴스 변수를 사용할 수 없다
  - 인스턴스가 존재하지 않을 수 있기 때문
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면 static 붙이는 것을 고려
  - 찾는 시간이 줄어들기 때문

### 12) 클래스 멤버와 인스턴스 멤버간의 참조와 호출
- 클래스멤버가 인스턴스멤버를 호출하거나 참조하려 할 때 인스턴스 생성이 필요
- 호출하거나 참조하는 시점에 인스턴스가 존재하지 않을 수 있기 때문

<br>

## 4. 오버로딩(overloading)

### 1) 오버로딩이란?
- 자바에서는 한 클래스 내에 이미 사용하려는 이름과 같은 메서드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메서드 정의 가능

### 2) 오버로딩의 조건
1. 메서드 이름이 같아야 한다
2. 매개변수의 개수 또는 타입이 달라야 한다
- 반환타입은 오버로딩을 구현하는데 아무 영향을 주지 않는다

### 3) 오버로딩의 예
- `PrintStream`클래스에는 10개의 오버로딩된 `println`메서드 존재
- 매개변수 타입의 순서가 달라도 오버로딩 가능

### 4) 오버로딩의 장점
- 같은 기능을 명시적으로 의미하고 메서드 이름 절약

### 5) 가변인자(varargs)와 오버로딩
- 매개변수의 개수를 동적으로 지정
- `타입...변수명`과 같은 형식으로 선언
- 가변인자 외 매개변수가 존재한다면 가변인자를 마지막에 선언

<br>

## 5. 생성자(Constructor)

### 1) 생성자란?
- 인스턴스 생성할 때 호출되는 인스턴스 `초기화` 메서드
1. 생성자 이름을 클래스 이름과 같아야한다
2. 생성자는 반환값이 없다
- `new` 연산자가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것은 아니다
  1. new 연산자에 의해 메모리(heap)에 인스턴스 생성
  2. 생성자가 호출되어 수행
  3. new 연산자 결과로 생성된 인스턴스의 주소가 반환되어 참조변수에 저장

### 2) 기본 생성자(default constructor)
- 생성자를 정의하지 않고 인스턴스를 생성할 수 있었던 이유는 `컴파일러`가 제공하는 기본 생성자 때문
- 컴파일러가 자동적으로 기본 생성자를 추가해주는 경우는 클래스 내에 생성자가 하나도 없을 때

### 3) 매개변수가 있는 생성자
- 코드를 보다 간결하고 직관적으로

### 4) 생성자에서 다른 생성자 호출하기 - this, this()
- 생성자의 이름으로 클래스이름 대신 `this`를 사용
- 생성자에서 다른 생성자를 호출할 때는 첫줄에서만 사용
  - 초기화하는 시점을 명확하게 하기 위함
- 매개변수와 인스턴스변수의 이름이 동일한 경우 `this`를 통해 구분
  - 사용하지 않을 경우 둘다 지역변수로 간주
- this는 참조변수로 인스턴스 자신을 가리킨다
  - this를 사용할 수 있는 것은 인스턴스멤버뿐

### 5) 생성자를 이용한 인스턴스의 복사
- 해당 인스턴스를 매개변수로 하는 생성자 생성 - 복사 생성자

<br>

## 6. 변수의 초기화

### 1) 변수의 초기화
- 변수를 선언하고 처음으로 값을 저장하는 것
- 필수적이기도 하고 선택적이기도 하지만 선언 동시에 적잘한 값으로 초기화하는 것이 바람직
- 멤버변수는 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어지지만 지역변수는 그렇지 않다

### 2) 명시적 초기화(explicit initialization)
- 변수를 선언과 동시에 초기화하는 방법

### 3) 초기화 블럭(initialization block)
- `클래스 초기화 블럭` : 클래스변수의 복잡한 초기화에 사용, `static{ ... }` 형태
- `인스턴스 초기화 블럭` : 인스턴스변수의 복잡한 초기화에 사용, `{ ... }` 형태
- 클래스 초기화 블럭은 클래스가 메모리에 로딩될 때 한번만 수행
- 인스턴스 초기화 블럭은 인스턴스가 생성될 때 마다 수행, 생성자보다 먼저 수행

### 4) 멤버변수의 초기화 시기와 순서
- `클래스변수의 초기화순서` : 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
- `인스턴스변수의 초기화순서` : 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자