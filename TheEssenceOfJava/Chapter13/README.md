# Chapter 13 쓰레드

## 1. 프로세스와 쓰레드

프로세스란 간단히 말해서 실행중인 프로그램이다.  
프로그램이 실행되면 OS로부터 자원(메모리)를 할당받아 프로세스가 된다.  
프로세스는 프로그램 실행에 필요한 데이터, 자원, 쓰레드로 구성되어 있으며 자원을 이용해 실제 작업을 수행하는 것이 쓰레드이다.

### 멀티태스킹과 멀티쓰레딩

대부분의 OS는 멀티태스킹을 지원하기 때문에 여러 개의 프로세스가 동시에 실행될 수 있다.  
멀티쓰레딩은 하나의 프로세스 내에서 여러 쓰레드가 동시에 작업을 수행하는 것이다.  
실제로 동시에 처리되는 작업의 개수는 CPU 코어의 개수와 일치한다.  
쓰레드 수는 코어의 개수보다 훨씬 많기 때문에 짧은 시간 동안 번갈아 가며 수행하기 때문에 동시에 수행되는 것처럼 보인다.

### 멀티쓰레딩의 장단점

장점
- CPU 사용률 향상
- 자원 효율적 사원
- 응답성의 향상
- 작업이 분리되어 코드가 간결

단점
- 동기화 문제 고려
- 교착상태 고려

<br>

## 2. 쓰레드의 구현과 실행

`Thread`클래스를 상속받는 방법과 `Runnable`인페이스를 구현하는 방법 2가지가 존재  
Thread클래스를 상속받으면 다른 클래스를 상속받을 수 없기에 Runnable인테페이스 구현이 일반적
```java
class MyThread extends Thread {
	@Override
	public void run() {
		/* 작업내용 */
	}
}
```
```java
class MyThread implements Runnable {
	public void run() {
		/* 작업내용 */
	}
}
```
쓰레드의 이름은 `생성자`나 `setName` 메서드를 통해 지정 또는 변경할 수 있다.  
쓰레드의 이름을 지정하지 않으면 `Thread-번호`의 형식으로 이름이 정해진다.

<br>

## 3. start()와 run()

`run`을 호출하는 것은 생성된 쓰레드를 실행시키는 것이 아니라 단순히 클래스에 선언된 메서드를 호출  
`start`는 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택을 생성한 다음 `run` 을 호출해서 생성된 호출스택에 `run`이 첫 번째로 올라가게 한다.  
쓰레드가 둘 이상일 때는 호출스택의 최상위에 있는 메서드일지라도 대기상태에 있을 수 있다.  
스케줄러는 실행대기중인 쓰레드의 우선선위를 고려하여 실행순서와 실행시간을 결정하고 각 쓰레드들은 스케줄러에 의해 동작하게 된다.

<br>

## 4. 싱글쓰레드와 멀티쓰레드

`context switching` : 쓰레드간의 작업 전환  
쓰레드도 코어와 프로세스에 영향을 받아 환경에 따라 다르게 동작할 수 있다.

<br>

## 5. 쓰레드의 우선순위

쓰레드는 `우선순위`라는 속성을 가지고 있는데 이 값에 따라 얻는 실행시간이 달라진다.  
쓰레드가 가질 수 있는 우선순위의 범위는 1~10이며 숫자가 높을수록 우선순위가 높다.  
쓰레드의 우선순위는 쓰레드를 생성한 쓰레드로부터 상속받는다는 것이다.  
쓰레드의 우선순위는 변경이 가능한데 쓰레드 실행전에만 가능하다.  
OS마다 다른 방식으로 스케쥴링하기 때문에 쓰레드에 우선순위를 부여하는 대신 작업에 우선순위를 두어 PriorityQueue에 저장해 놓고, 우선순위가 높은 작업이 먼저 처리되도록

<br>

## 6. 쓰레드 그룹(thread group)

관련된 쓰레드를 그룹으로 다루기 위한 것  
쓰레드 그룹에 다른 쓰레드 그룹을 포함시킬 수 있다.  
보안상 이유로 자신이 속한 쓰레드 그룹이나 하위 쓰레드 그룹은 변경할 수 있지만 다른 쓰레드 그룹의 쓰레드를 변경할 수 없다.  
모든 쓰레드는 반드시 쓰레드 그룹에 포함되어 있어야 하기 때문에 쓰레드 그룹을 지정하는 생성자를 사용하지 않는 쓰레드는 기본적으로 자신을 생성한  쓰레드와 같은 쓰레드 그룹에 속함

<br>

## 7. 데몬 쓰레드(daemon thread)

데몬 쓰레드는 다른 일반 쓰레드의 작업을 돕는 보조적인 역할을 수행하는 쓰레드  
일반 쓰레드가 모두 종료되면 데몬 쓰레드는 강제적으로 자동 종료  
작성방법과 실행방법은 일반 쓰레드와 같으며 실행하기 전 `setDaemon(true)` 를 호출  
데몬 쓰레드가 생성한 쓰레드는 자동적으로 데몬 쓰레드가 된다.

<br>

## 8. 쓰레드의 실행제어

쓰레드 프로그래밍이 어려운 이유는 `동기화`와 `스케쥴링` 때문이다.

### 쓰레드의 상태

`NEW` : 쓰레드가 생성되고 아직 start가 호출되지 않은 상태  
`RUNNABLE` : 실행 중 또는 실행 가능한 상태  
`BLOCKED` : 동기화블럭에 의해서 일시정지된 상태(lock이 풀릴 때까지 기다리는 상태)  
`WAITING`, `TIMED_WAITING` : 쓰레드의 작업이 종료되지는 않았지만 실행가능하지 않은 일시정지 상태, TIMED는 일시정지시간이 지정된 경우를 의미  
`TERMINATED` : 쓰레드의 작업이 종료된 상태

### sleep

일정시간동안 쓰레드를 멈추게 한다.  
항상 현재 실행 중인 쓰레드에 대해 작동하기 때문에 참조변수를 이용해 호출하기 보다는 Thread.sleep()을 사용

### interupt, interrupted

interupt()는 쓰레드에게 작업을 멈추라고 요청, 단지 멈추라고 요청만 하는 것일 뿐 쓰레드를 강제로 종료시키지는 못한다.  
interupted()는 쓰레드에 대해 interupt()가 호출되었는지 알려준다.

### sespend, resume, stop

sespend는 쓰레드를 멈추게 한다. sespend에 의해 정지된 쓰레드는 resume을 호출해야 다시 실행대기 상태가 된다.  
stop은 호출되는 즉시 쓰레드가 종료된다.  
쓰레드 실행을 제어하는 가장 손쉬운 방법이지만 교착상태(deadlock)을 일으키기 쉽게 작성되어있으므로 사용이 권장되지 않는다.

### yield

다른 쓰레드에게 양보한다.  
적절히 사용하면 프로그램의 응답성을 높이고 보다 효율적인 실행이 가능하게 할 수 있다.

### join

다른 쓰레드의 작업을 기다린다.

<br>

## 9. 쓰레드의 동기화

한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것을 쓰레드의 동기화라고 한다.

### 1. synchronized를 이용한 동기화

임계 영역을 지정하면 자동으로 lock을 얻고 반환한다.  
임계 영역은 멀티쓰레드 프로그램의 성능을 좌우하기 때문에 가능하면 임계 영역을 최소화하는 것이 효율적인 프로그램 작성에 도움을 준다.

### 2. wait()와 notify()

`wait` 를 호출하면 쓰레드가 락을 반납하고 기다리게 한다.  
`notify` 를 호출하면 작업을 중단했던 쓰레드가 다시 락을 얻어 작업을 진행할 수 있다.

### 3. Lock과 Condition을 이용한 동기화

무조건 읽기 lock을 걸리 않고 쓰기와 읽기가 충돌할 때만 쓰기가 끝난 후에 읽기 lock을 거는 것이다.

### 4. volatile

해당 키워드를 붙이면 캐시가 아닌 메모리에서 값을 읽어오기 때문에 캐시와 메모리간의 값의 불일치가 해결된다.

### 5. fork & join 프레임웍

`fork` 는 작업을 쓰레드의 작업 큐에 넣는 것이고, 작업 큐에 들어간 작업은 더 이상 나눌 수 없을 때까지 나뉜다.  
작업의 결과는 `join`을 호출해서 얻을 수 있다.