# Chapter 12 지네릭스, 열거형, 애너테이션

## 1. 지네릭스(Generics)

### 1) 지네릭스란?

다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시 타입 체크를 해주는 기능  
객체의 타입을 컴파일 시 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다.

`장점`
- 타입 안정성을 제공
- 타입체크와 형변환을 생략할 수 있으므로 코드 간략

### 2) 지네릭 클래스의 선언

의미 있는 문자를 사용해서 정의하는 것을 `타입 변수`

`용어`
```java
class Box<T> {}
```
- Box<T> : 지네릭 클래스. T의 Box 또는 T Box
- T : 타입 변수 or 타입 매개변수
- Box : 원시 타입

`제한`
- static멤버에 타입 변수 T를 사용할 수 없다. T는 인스턴스 변수로 간주되기 때문
- 지네릭 타입의 배열 생성은 불가능하지만 지네릭 배열 타입의 참조변수를 선언하는 것은 가능
  - new 생성자는 컴파일 시점에 타입을 명확히 알아야하는데 T는 그렇지 못하기 때문

### 3) 지네릭 클래스의 객체 생성과 사용

객체를 생성할 때는 타입이 일치해야하는데 두 타입이 상속관계에 있어도 생성 불가  
하지만, 두 지네릭 클래스가 상속관계에 있을 때 타입이 동일하다면 가능

### 4) 제한된 지네릭 클래스

`extends` 를 사용하면 특정 타입의 자손들만 대입  
인터페이스의 구현이 필요할 때도 `extends` 를 사용
```java
// 동시 사용
class FruitBox<T extends Fruit & Eatable> { ... }
```

### 5) 와일드 카드

타입을 지정해두면 여러 메서드를 오버로딩해야하는 단점  
하지만 오버로딩도 할 수 없다 → 지네릭 타입이 다르다는 점은 오버로딩의 조건이 될 수 없기 때문

`?`
- 와일드 카드
- <? extends T> : 상한 설정, T와 그 자손들만 가능
- <? super T> : 하한 설정, T와 그 조상들만 가능
- <?> : 전부 가능

### 6) 지네릭 메서드

선언 위치는 반환 타입 바로 앞  
지네릭 클래스에 정의된 타입 매개변수와 지네릭 메서드에 정의된 타입 매개변수는 다른 것!  
메서드에 사용된 타입 매개변수는 메서드 내에서만 지역적으로 사용되기 때문에 static 메서드에서도 가능하며 타입 문자가 같아도 구분할 수 있다.

### 7) 지네릭 타입의 형변환

타입이 정해진 클래스 간 형변환은 불가능하지만 와일드 카드가 포함된 지네릭 타입으로의 형변환은 가능하다.

### 8) 지네릭 타입의 제거

컴파일러는 지네릭 타입을 이용해서 소스파일을 체크하고, 필요한 곳에 형변환을 넣어준다. 그리고 지네릭 타입을 제거한다.  
즉, 컴파일된 클래스 파일에는 지네릭 타입이 존재하지 않는다.
1. 지네릭 타입의 경계를 제거한다.
  - extends면 상위 타입으로 치환
2. 지네릭 타입을 제거한 후 타입이 일치하지 않으면 형변환을 추가

<br>

## 2. 열거형(enums)

### 1) 열거형이란?

자바의 열거형은 타입에 안전한 열거형(typesafe enum)이라서 실제 값이 같아도 타입이 다르면 컴파일 에러가 발생한다.  
상수의 값이 바뀌면 상수를 참조하는 모든 소스 파일을 다시 컴파일 해야하지만, 열거형 상수를 사용하면 기존의 소스를 다시 컴파일하지 않아도 된다.

### 2) 열거형의 정의와 사용

열거형은 `==` 비교 연산자를 통한 비교가 가능하고 따라서 빠른 성능을 제공한다.

### 3) 열거형에 멤버 추가하기

ordinal()이 정의된 순서를 반환하지만, 열거형 상수의 값으로 사용하지 않는 것이 좋다.
- 내부적인 용도로만 사용되기 위한 것

값 추가만으로는 용도가 부족하기에 추상 메서드를 추가할 수 있다.
- `protected`로 선언해야 각 상수에서 접근이 가능하다.

### 4) 열거형의 이해

열거형 상수 하나하나가 Presentation.Enum 객체이다.

<br>

## 3. 애너테이션 (annotation)

### 1) 애너테이션이란?

소스코드에 대한 문서를 따로 만들기보다는 소스코드와 문서를 하나의 파일로 관리하는 것이 좋다고 판단  
이 기능을 응용하여, 프로그램 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것이 바로 애너테이션이다.

### 2) 표준 애너테이션

@Override
- 컴파일러는 조상 메서드를 잘못 쓰더라도 인지하지 못하는데 이 애너테이션을 사용하면 조상 메서드를 확인하고 없으면 에러메시지를 출력한다.

@Deprecated
- 더 이상 사용되지 않는 필드나 메서드에 붙여 더 이상 사용하지 않을 것을 권장한다.

@FunctionalInterface
- 함수형 인터페이스를 선언할 때 붙이면 컴파일러가 올바르게 선언했는지 확인하고, 잘못된 경우 에러를 발생시킨다.

@SuppressWarnings
- 컴파일러가 보여주는 경고메시지가 나타나지 않게 억제해준다.

### 3) 메타 애너테이션

애너테이션을 위한 애너테이션을 의미한다.

@Target
- 애너테이션이 적용 가능한 대상을 지정하는데 사용한다.

@Retention
- 애너테이션이 유지되는 기간을 지정하는데 사용한다.

@Documented
- 애너테이션 정보가 javadoc으로 작성한 문서에 포함되도록 한다.

@Inherited
- 조상 클래스의 애너테이션이 자손 클래스까지 영향을 주도록 한다.

@Repeatable
- 애너테이션을 여러번 붙일 수 있도록 해준다.

### 4) 애너테이션 타입 정의하기

새로운 애너테이션을 정의하는 방법은 인터페이스 정의에서 @를 붙이는 것이다.  
애너테이션 내에 선언된 메서드를 `애너테이션의 요소`라고 한다.
- 반환값이 있고 매개변수는 없는 추상 메서드의 형태를 가지며 상속을 통해 구현하지 않아도 된다.
- 애너테이션을 적용할 때는 요소들의 값을 빠짐없이 지정해줘야 한다.
- 애너테이션의 요소는 기본값을 가질 수 있으면 기본값이 있다면 값을 지정하지 않아도 된다.

`마커 애너테이션`
- 값을 지정할 필요가 없는 경우 애너테이션 요소를 하나도 정의하지 않을 수 있다.

`애너테이션 요소의 규칙`
- 요소의 타입은 기본형, String, enum, 애너테이션, Class만 허용한다.
- ()안에 매개변수를 선언할 수 없다.
- 예외를 선언할 수 없다.
- 요소를 타입 매개변수로 정의할 수 없다.